# Асинхронное и параллельное программирование

Асинхронное и параллельное программирование — это методы, позволяющие выполнять несколько задач одновременно для увеличения эффективности и скорости работы программы в зависимости от типа задачи и доступных ресурсов.

## Параллельное программирование

Параллельное программирование позволяет выполнить несколько задач одновременно, распределяя их между несколькими процессорами или ядрами процессора. В Python для параллельного программирования часто используется модуль `multiprocessing`. Он позволяет создавать процессы, каждый из которых выполняется независимо, и обеспечивает механизмы для передачи данных между процессами и выполнения параллельных задач.

Рассмотрим пример программы, которая создает очередь для передачи данных между вводом/выводом и рабочим процессом. Пусть программа позволяет пользователю вводить числа с клавиатуры, которые в другом процессе записываются в файлы.

```python
import multiprocessing
import time


def process(i: int):
    """
    Функция, которая представляет собой задачу обработки.
    Ждет i секунд и записывает строку в файл с именем {i}.txt.
    :param i: Время обработки, число для сохранения.
    :return:
    """

    time.sleep(i)
    with open(f'{i}.txt', 'w', encoding='utf-8') as file:
        file.write(f'Hello, {i}!')


def worker(queue: multiprocessing.Queue):
    """
    Бесконечно извлекает элементы из очереди и отправляет их на обработку функции process.
    :param queue: Очередь элементов для обработки.
    :return:
    """

    while True:
        process(queue.get())


def iostream(queue: multiprocessing.Queue):
    """
    Ждет ввода с консоли до тех пор, пока не будет введено нечисловое значение.
    Введенные числа добавляются в очередь для последующей обработки.
    :param queue: Очередь элементов для обработки.
    :return:
    """

    while True:
        n = input("Введите число: ")
        if not n.strip().isdigit():
            break
        queue.put(int(n))


def main():
    """
    Создает отдельный поток для обработки элементов и дожидается его завершения.
    Также обрабатывает основной поток.
    :return:
    """

    # Создание очереди элементов для обработки
    queue = multiprocessing.Queue()

    # Создание процесса
    worker_process = multiprocessing.Process(target=worker, args=(queue,))

    # Обработка в отдельном потоке
    print('Начало работы')
    worker_process.start()

    # Ввод в основном потоке
    iostream(queue)

    # Ожидание обработки оставшихся в очереди элементов
    print('Завершение работы')
    while not queue.empty():
        pass

    # Завершение процесса
    worker_process.terminate()
    while worker_process.is_alive():
        pass
    worker_process.close()
    print('Конец работы')


if __name__ == '__main__':
    # Запуск основной функции
    main()
```

## Асинхронное программирование

Асинхронное программирование позволяет создавать эффективные и отзывчивые программы, которые не блокируются при ожидании завершения операций ввода/вывода (I/O) или других задержек. В Python для этого используется модуль `asyncio`. Он предоставляет средства для написания асинхронного кода с использованием ключевых слов `async` и `await`. Модуль основан на концепции корутин (coroutines) и позволяет организовать параллельное выполнение множества задач, используя один поток исполнения.

Рассмотрим пример программы, которая создает очередь для передачи данных между вводом/выводом и рабочим процессом. Пусть программа позволяет пользователю вводить числа с клавиатуры, которые асинхронно записываются в файлы.

```python
import asyncio
from contextlib import suppress
from aioconsole import ainput


async def process(i: int):
    """
    Асинхронная функция, которая представляет собой задачу обработки.
    Ждет i секунд и записывает строку в файл с именем {i}.txt.
    :param i: Время обработки, число для сохранения.
    :return:
    """

    await asyncio.sleep(i)
    with open(f'{i}.txt', 'w', encoding='utf-8') as file:
        file.write(f'Hello, {i}!')


async def worker(queue: asyncio.Queue):
    """
    Асинхронный рабочий процесс, который бесконечно извлекает элементы из очереди
    и отправляет их на обработку функции process.
    :param queue: Очередь элементов для обработки.
    :return:
    """

    while True:
        i = await queue.get()
        await process(i)
        queue.task_done()


async def iostream(queue: asyncio.Queue):
    """
    Асинхронный процесс, который ждет ввода с консоли до тех пор, пока не будет введено нечисловое значение.
    Введенные числа добавляются в очередь для последующей обработки.
    :param queue: Очередь элементов для обработки.
    :return:
    """

    while True:
        n = await ainput("Введите число: ")
        if not n.strip().isdigit():
            break
        await queue.put(int(n))


async def manager(queue: asyncio.Queue, iostream_task: asyncio.Task, worker_task: asyncio.Task):
    """
    Менеджер координирует работу между вводом/выводом и рабочим процессом.
    Дожидается окончания ввода/вывода и обработки накопившейся очереди и завершает рабочий процесс.
    :param queue: Очередь элементов для обработки.
    :param iostream_task: Процесс ввода/вывода.
    :param worker_task: Рабочий процесс.
    :return:
    """

    await iostream_task
    print('Завершение работы')
    await queue.join()
    worker_task.cancel()
    await worker_task


async def main():
    """
    Основная функция, которая создает асинхронные задачи для ввода/вывода, рабочего процесса и менеджера и дожидается их завершения.
    :return:
    """

    # Создание очереди элементов для обработки
    queue = asyncio.Queue()

    # Создание задач
    worker_task = asyncio.create_task(worker(queue))
    iostream_task = asyncio.create_task(iostream(queue))
    manager_task = asyncio.create_task(manager(queue, iostream_task, worker_task))

    # Одновременное выполнение задач
    print('Начало работы')
    with suppress(asyncio.exceptions.CancelledError):  # Подавление CancelledError (возникает при отмене задачи)
        await asyncio.gather(iostream_task, worker_task, manager_task)
    print('Конец работы')


if __name__ == "__main__":
    # Запуск основной функции
    asyncio.run(main())
```

> **Обрати внимание!** В асинхронном коде используется только один поток исполнения, а функция `input` его блокирует. Есть библиотека `aioconsole`, где на низком уровне правильно организована работа с консолью. Это позволяет не блокировать единственный поток, используя `ainput` с `await` вместо обычного `input`.
