# Объектно-ориентированное программирование (ООП)

ООП — это парадигма программирования, используемая для структурирования и организации кода в виде объектов, которые взаимодействуют друг с другом.

Классы представляют собой шаблоны или чертежи для создания объектов. Они определяют атрибуты (переменные) и методы (функции), которые будут доступны объектам данного класса.
В Python классы определяются с использованием ключевого слова `class`.

Объекты являются конкретными экземплярами классов. Создаются на основе классов с использованием конструктора класса.

Конструктором класса является метод `__init__`, который вызывается при создании нового объекта.
В конструкторе можно задать начальные значения атрибутов объекта.

Атрибуты — это переменные, принадлежащие объектам класса. Они могут быть уникальными для каждого объекта (экземпляра) или общими для всех объектов данного класса. Атрибуты могут быть определены внутри методов класса или в конструкторе.

Методы — это функции, принадлежащие объектам класса. Они могут выполнять операции с данными объекта или возвращать значения. Методы могут быть общими для всех объектов класса или уникальными для каждого объекта.

«Dunder»-методы (также известные как специальные методы или магические методы) — это специальные методы с двойными подчеркиваниями в начале и в конце имени. Их много, они предоставляют возможность переопределять стандартное поведение операторов и встроенных функций для объектов данного класса. Например, `__init__` — специальный метод, вызываемый при создании объекта, `__str__` используется для определения строкового представления объекта, `__add__` определяет поведение оператора `+` для экземпляров класса и так далее.

```python
class Circle:
    def __init__(self, radius):
        self.radius = radius
    
    def __str__(self):
        return f"Круг радиусом {self.radius}"
    
    def __add__(self, other):
        if isinstance(other, Circle):
            return Circle(self.radius + other.radius)
        raise TypeError


circle1 = Circle(5)
circle2 = Circle(3)
circle = circle1 + circle2

print(circle1)  # Вывод: "Круг радиусом 5"
print(circle2)  # Вывод: "Круг радиусом 3"
print(circle)  # Вывод: "Круг радиусом 8"
```

Статические методы — методы, которые привязаны к классу, а не к экземпляру класса. Вызываются через имя класса, а не через экземпляр. Статические методы в Python объявляются с использованием декоратора `@staticmethod`. Они не требуют доступа к экземпляру (`self`) и могут использоваться, даже если у вас вообще нет экземпляров класса. Это полезно, когда функциональность не зависит от состояния экземпляра, и не требуется доступа к атрибутам экземпляра.

```python
class MathOperations:
    @staticmethod
    def add(x, y):
        return x + y

    @staticmethod
    def multiply(x, y):
        return x * y

# Вызов статических методов через имя класса
sum_result = MathOperations.add(3, 5)
product_result = MathOperations.multiply(4, 6)

print(f"Сумма: {sum_result}")  # Вывод: Сумма: 8
print(f"Произведение: {product_result}")  # Вывод: Произведение: 24
```

## Основные концепции

### Абстракция

Абстрактные классы в Python — это классы, которые не могут быть инстанциированы напрямую.
Они служат для определения интерфейсов, которые другие классы должны реализовать. Такие классы
могут содержать абстрактные методы, которые не имеют реализации в самом абстрактном классе,
но должны быть реализованы в классах-наследниках. Это позволяет определять общие интерфейсы с различной реализацией каждого конкретного класса-наследника.

Для создания абстрактных классов в Python используется модуль `abc` (Abstract Base Classes).

```python
from abc import ABC, abstractmethod

class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

    @abstractmethod
    def perimeter(self):
        pass

class Square(Shape):
    def __init__(self, side_length):
        self.side_length = side_length

    def area(self):
        return self.side_length ** 2

    def perimeter(self):
        return 4 * self.side_length

class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return 3.14 * self.radius ** 2

    def perimeter(self):
        return 2 * 3.14 * self.radius


# Пример использования
square = Square(5)
circle = Circle(3)

print("Площадь квадрата:", square.area())       # Вывод: 25
print("Периметр квадрата:", square.perimeter())  # Вывод: 20
print("Площадь круга:", circle.area())           # Вывод: 28.26
print("Периметр круга:", circle.perimeter())     # Вывод: 18.84
```

В приведенном примере `Shape` — это абстрактный класс с абстрактными методами `area` и `perimeter`. Классы `Square` и `Circle` являются классами-наследниками, которые обязаны реализовать оба эти метода. Если какой-то из абстрактных методов не реализован в классе-наследнике, при попытке создания экземпляра такого класса будет исключение `TypeError`.

### Наследование

Наследование позволяет создавать новые классы на основе существующих классов. Класс-наследник получает атрибуты и методы родительского класса и может их дополнять и/или переопределять без необходимости повторного написания кода. Наследование в Python осуществляется добавлением к имени класса круглых скобок с указанием внутри класса-предка: `class A(B)`.

### Инкапсуляция

Данные (переменные) и методы, которые работают с этими данными, обычно объединены внутри класса. Соответственно, можно скрыть детали реализации и предоставить интерфейс для работы с объектами. Этот принцип называется инкапсуляцией.

В Python есть три уровня доступа к атрибутам и методам класса.

#### Публичные атрибуты и методы

Доступны из любого места программы. Публичные атрибуты обычно определяются без использования специальных префиксов или суффиксов.

#### Защищенные атрибуты и методы

Доступны только внутри класса и его наследников. Защищенные атрибуты обычно определяются с использованием префикса `_` (одного нижнего подчеркивания) перед их именем. Например, `_protected_attribute`.

#### Приватные атрибуты и методы

Доступны только внутри класса, не доступны извне. Приватные атрибуты обычно определяются с использованием префикса `__` (двух нижних подчеркиваний) перед их именем. Например, `__private_attribute`.

На самом деле, важно отметить, что Python использует механизм «сокрытия имени» для приватных атрибутов и методов. При определении приватного атрибута или метода, его имя изменяется путем добавления префикса `_ClassName` перед именем. Иными словами, нет строгой защиты от доступа к защищенным и приватным атрибутам и методам извне, поэтому существует соглашение, называемое «силой положительного намерения» (The Principle of Least Astonishment), которое говорит, что приватные атрибуты и методы предназначены лишь для обозначения их внутреннего использования.

```python
class MyClass:
    def __init__(self):
        self.public_attribute = "Это публичный атрибут"
        self._protected_attribute = "Это защищенный атрибут"
        self.__private_attribute = "Это приватный атрибут"

    def public_method(self):
        return "Это публичный метод"

    def _protected_method(self):
        return "Это защищенный метод"

    def __private_method(self):
        return "Это приватный метод"

    
obj = MyClass()

print(obj.public_attribute)  # Вывод: "Это публичный атрибут"
print(obj._protected_attribute)  # Вывод: "Это защищенный атрибут"
print(obj._MyClass__private_attribute)  # Вывод: "Это приватный атрибут"

print(obj.public_method())  # Вывод: "Это публичный метод"
print(obj._protected_method())  # Вывод: "Это защищенный метод"
print(obj._MyClass__private_method())  # Вывод: "Это приватный метод"
```

### Полиморфизм

Полиморфизм позволяет объектам разных классов иметь общий интерфейс, но вести себя по-разному.
Так можно использовать объекты разных классов в универсальных операциях. Например, у разных классов может быть метод `speak`, и реализован он будет по-разному.

```python
class Animal:
    def __init__(self, name):
        self.name = name

    def speak(self):
        pass

class Dog(Animal):
    def speak(self):
        return f"{self.name} говорит 'Гав!'"

class Cat(Animal):
    def speak(self):
        return f"{self.name} говорит 'Мяу!'"

dog = Dog("Бобик")
cat = Cat("Мурзик")

print(dog.speak())  # Вывод: "Бобик говорит 'Гав!'"
print(cat.speak())  # Вывод: "Мурзик говорит 'Мяу!'"
```
