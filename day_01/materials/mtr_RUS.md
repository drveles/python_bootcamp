# Темы

1. Точка входа в программу, структура программы
2. Компиляция/интерпретация программы
3. Управляющие структуры языка (следование, ветвление, повторение)
4. Простые типы данных
5. Составные типы данных
6. Организация ввода-вывода (stdin-stdout)
7. Управление памятью, сборщик мусора
8. Сложные структуры данных
9. Обработка исключений
10. Работа с файлами
11. Функции

# Методические указания к заданиям

## Скалярное произведение

Скалярное произведение — это математическая операция, применяемая к двум векторам в трехмерном пространстве
(или более общем n-мерном пространстве) и возвращающая скалярную величину.

Для двух векторов `a = [a1, a2, ..., an]` и `b = [b1, b2, ..., bn]`,
скалярное произведение вычисляется следующим образом:
`a * b = a1 * b1 + a2 * b2 + ... + an * bn`.
Это число представляет собой сумму произведений соответствующих компонент векторов.

## Палиндром

Палиндром — это число, которое читается слева направо и справа налево одинаково.
Соответственно, чтобы определить, является число палиндромом или нет, необходимо убедиться в том, что
цифры в начале и в конце числа, находящиеся на одинаковом расстоянии от середины, совпадают.
Предварительно, следует получить цифры числа. Можно привести число к строке и для получения цифр
обращаться по индексам, но эффективнее сформировать список цифр, пользуясь в цикле операциями
целочисленного деления.

## Фигуры

Для нахождения фигур в матрице предлагается написать алгоритм, который в процессе обхода матрицы по
строкам или столбцам будет для любой встретившейся на пути единицы запускать рекурсивный обход всех
единиц, смежных с ней. При этом, естественно, необходимо заменять на нули посещенные единицы, чтобы
посчитать каждую только один раз. Определить, является фигура кругом или квадратом, можно по-разному.
Один из вариантов - во время обхода посчитать количество единиц, а также сохранить индекс самой левой,
самой правой, самой нижней и самой верхней встретившихся единиц, чтобы затем сравнить ожидаемую площадь
квадрата (максимальная ширина области * максимальную высоту области) с найденным количеством единиц.
Если площади совпадут, то это квадрат, а иначе круг.

## Треугольник Паскаля

Треугольник Паскаля — это числовой треугольник, в котором каждое число равно сумме двух чисел,
расположенных над ним. Верхний ряд треугольника содержит число 1, а каждое следующее число в
треугольнике вычисляется как сумма двух чисел над ним в предыдущем ряду.

```
    1
   1 1
  1 2 1
 1 3 3 1
1 4 6 4 1
```

## Преобразование строки в число

Для преобразования строки в вещественное число, предлагается написать алгоритм, которые посимвольно обработает
входную строку и соберет всю необходимую информацию о числе. Затем использует ее для получения самого числа.
Как вариант, можно сохранить в булеву переменную, является ли число положительным, а в список - цифры итогового числа.
В отдельную переменную записать количество цифр после точки, а после восстановить число, умножая каждую цифру на 10
в нужной степени, затем делить на 10 в соответствии с количеством цифр после точки и умножить на -1, если было
введено отрицательное число.

## Фильмы

Работать с форматом json удобно с помощью модуля `json`, в котором есть функция `loads()` для получения информации из
json строки в виде словаря `dict`, и антонимичная функция `dumps()` для конвертирования словаря `dict` в json строку.
Если в функцию `loads()` передать строку, не соответствующую формату json, будет сгенерировано исключение
`JSONDecodeError`. Необходимо предусмотреть такую ситуацию, отловив возможное исключение. Также можно отловить
ошибку во входных данных, связанную с отсутствием необходимых полей в словаре. Это можно сделать, используя метод
`get()`, передав в него значение по умолчанию, или отловив возможное исключение `KeyError`.
Алгоритм для объединения двух отсортированных списков в один отсортированный список должен проходить по данным
один раз. Иными словами, если склеить два списка, а затем отсортировать, будет получен правильный список, но такой
алгоритм не самый эффективный, поэтому не рекомендуется к использованию.

## Робот

Из каждой клетки поля робот может пойти либо вниз, либо вправо, поэтому количество возможных траекторий робота от
старта до финиша очень велико. Следовательно, алгоритм, перебирающий все возможные траектории робота для нахождения
наиболее удачного, будет работать крайне медленно, поэтому не рекомендуется к использованию. Вместо этого предлагается
использовать другой алгоритм, основанный на идеях динамического программирования. Метод динамического программирования
используется для оптимизации задач, которые можно разбить на более мелкие подзадачи. При этом решения мелких подзадач
могут быть сохранены и использованы для решения более крупной задачи. В данном случае, поскольку робот может попасть в
любую клетку только сверху или слева, логично выбирать наиболее выгодный из этих двух вариантов. Это и будет мелкая
подзадача, которая решается простым выбором из двух вариантов. А далее, начиная с верхней левой клетки,
можно для каждой следующей за ней справа и снизу быть уверенным в том, что в нее робот уже смог попасть наиболее
выгодным образом. То есть, решаем ту же мелкую подзадачу для каждой следующей клетки. Так дойдя до правого нижнего
угла поля, получим наибольшее количество монет, которое можно было набрать при наилучшем раскладе. То есть, более
крупная задача будет решена. При этом не придется перебирать все маршруты робота.

## Различные числа

Для подсчета количества различных введенных чисел придется их сохранять, чтобы каждый раз определять, встречалось
такое число или еще нет. Использовать список для сохранения встретившихся чисел - не самый эффективный способ,
поскольку придется для каждого нового числа проверять, есть ли оно уже в списке, а эта операция включает в себя
перебор всех элементов списка. Зато можно воспользоваться множеством. Операция проверки принадлежности числа
множеству значительно быстрее аналогичной операции у списка. Альтернативный вариант - использование словаря.
В нем обсуждаемая операция тоже быстрая, но памяти потребуется немного больше.

## Производная в точке

Производная многочлена вычисляется как сумма производных каждого его члена. Например, производной по `x` многочлена
`5 * x**2 + 1.2 * x - 3` будет сумма производных `5 * x**2`, `1.2 * x` и `-3`. При этом найти производную каждого
слагаемого вида `a * x**n` можно по формуле `a * n * x**(n - 1)`. Производная константы равна нулю. Так для
приведенного многочлена получим производную `10 * x + 1.2`. А посчитать производную многочлена в точке можно,
подставив в полученное выражение данное значение `x`. Производная в точке `3.0` тогда будет равна `10 * 3 + 1.2 = 31.2`.
Алгоритм для подсчета производной может в процессе считывания данных сразу находить и накапливать итоговую сумму
производных слагаемых.

## Аппараты

Для решения задачи удобно использовать словари `dict`, чтобы разделить аппараты по годам выпуска (хранить отдельно
аппараты разных годов, так как искомые два аппарата обязательно должны быть одного года выпуска). Более того,
хранить информацию об аппаратах тоже удобно в словаре. Если ключом будет время работы аппарата, то можно в процессе
сохранения информации сразу проверять, есть ли в словаре другой аппарат, у которого время в сумме с данным даст
требуемое значение. И поскольку нужно минимизировать стоимость, можно для каждого времени работы в таком словаре
оставлять минимальную стоимость аппарата, тогда и сумма получится минимальной в итоге. Соответственно, для каждого
года в словаре получится свой ответ и останется выбрать минимальный из них.
